/*
Infobip Client API Libraries OpenAPI Specification

OpenAPI specification containing public endpoints supported in client API libraries.

Contact: support@infobip.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package voice

import (
	"encoding/json"
	"fmt"
)

// DialogHangupSource the model 'DialogHangupSource'
type DialogHangupSource string

// List of DialogHangupSource
const (
	DIALOGHANGUPSOURCE_API             DialogHangupSource = "API"
	DIALOGHANGUPSOURCE_PARENT_ENDPOINT DialogHangupSource = "PARENT_ENDPOINT"
	DIALOGHANGUPSOURCE_CHILD_ENDPOINT  DialogHangupSource = "CHILD_ENDPOINT"
	DIALOGHANGUPSOURCE_PLATFORM        DialogHangupSource = "PLATFORM"
)

// All allowed values of DialogHangupSource enum
var AllowedDialogHangupSourceEnumValues = []DialogHangupSource{
	"API",
	"PARENT_ENDPOINT",
	"CHILD_ENDPOINT",
	"PLATFORM",
}

func (v *DialogHangupSource) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := DialogHangupSource(value)
	for _, existing := range AllowedDialogHangupSourceEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid DialogHangupSource", value)
}

// NewDialogHangupSourceFromValue returns a pointer to a valid DialogHangupSource
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewDialogHangupSourceFromValue(v string) (*DialogHangupSource, error) {
	ev := DialogHangupSource(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for DialogHangupSource: valid values are %v", v, AllowedDialogHangupSourceEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v DialogHangupSource) IsValid() bool {
	for _, existing := range AllowedDialogHangupSourceEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to DialogHangupSource value
func (v DialogHangupSource) Ptr() *DialogHangupSource {
	return &v
}

type NullableDialogHangupSource struct {
	value *DialogHangupSource
	isSet bool
}

func (v NullableDialogHangupSource) Get() *DialogHangupSource {
	return v.value
}

func (v *NullableDialogHangupSource) Set(val *DialogHangupSource) {
	v.value = val
	v.isSet = true
}

func (v NullableDialogHangupSource) IsSet() bool {
	return v.isSet
}

func (v *NullableDialogHangupSource) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDialogHangupSource(val *DialogHangupSource) *NullableDialogHangupSource {
	return &NullableDialogHangupSource{value: val, isSet: true}
}

func (v NullableDialogHangupSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDialogHangupSource) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
