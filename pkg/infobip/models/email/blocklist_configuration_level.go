/*
Infobip Client API Libraries OpenAPI Specification

OpenAPI specification containing public endpoints supported in client API libraries.

Contact: support@infobip.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package email

import (
	"encoding/json"
	"fmt"
)

// BlocklistConfigurationLevel Defines the level at which Infobip stores unsubscribe preferences.  Note: When you change the unsubscribe configuration from a more global level (such as FROM_DOMAIN) to a more specific level (such as FROM_SENDER), remember that anyone who previously unsubscribed at the domain level chose to stop receiving all messages from your domain. These existing unsubscribe records will not automatically update to reflect the new sender-level setting. As a result, individuals who unsubscribed from your domain will continue to not receive messages, even after the change. To prevent confusion and respect user preferences, carefully manage and, if necessary, update these records when altering unsubscribe settings.
type BlocklistConfigurationLevel string

// List of BlocklistConfigurationLevel
const (
	BLOCKLISTCONFIGURATIONLEVEL_SENDER BlocklistConfigurationLevel = "FROM_SENDER"
	BLOCKLISTCONFIGURATIONLEVEL_DOMAIN BlocklistConfigurationLevel = "FROM_DOMAIN"
)

// All allowed values of BlocklistConfigurationLevel enum
var AllowedBlocklistConfigurationLevelEnumValues = []BlocklistConfigurationLevel{
	"FROM_SENDER",
	"FROM_DOMAIN",
}

func (v *BlocklistConfigurationLevel) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := BlocklistConfigurationLevel(value)
	for _, existing := range AllowedBlocklistConfigurationLevelEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid BlocklistConfigurationLevel", value)
}

// NewBlocklistConfigurationLevelFromValue returns a pointer to a valid BlocklistConfigurationLevel
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewBlocklistConfigurationLevelFromValue(v string) (*BlocklistConfigurationLevel, error) {
	ev := BlocklistConfigurationLevel(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for BlocklistConfigurationLevel: valid values are %v", v, AllowedBlocklistConfigurationLevelEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v BlocklistConfigurationLevel) IsValid() bool {
	for _, existing := range AllowedBlocklistConfigurationLevelEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to BlocklistConfigurationLevel value
func (v BlocklistConfigurationLevel) Ptr() *BlocklistConfigurationLevel {
	return &v
}

type NullableBlocklistConfigurationLevel struct {
	value *BlocklistConfigurationLevel
	isSet bool
}

func (v NullableBlocklistConfigurationLevel) Get() *BlocklistConfigurationLevel {
	return v.value
}

func (v *NullableBlocklistConfigurationLevel) Set(val *BlocklistConfigurationLevel) {
	v.value = val
	v.isSet = true
}

func (v NullableBlocklistConfigurationLevel) IsSet() bool {
	return v.isSet
}

func (v *NullableBlocklistConfigurationLevel) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableBlocklistConfigurationLevel(val *BlocklistConfigurationLevel) *NullableBlocklistConfigurationLevel {
	return &NullableBlocklistConfigurationLevel{value: val, isSet: true}
}

func (v NullableBlocklistConfigurationLevel) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableBlocklistConfigurationLevel) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
