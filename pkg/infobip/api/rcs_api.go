/*
Infobip Client API Libraries OpenAPI Specification

OpenAPI specification containing public endpoints supported in client API libraries.

Contact: support@infobip.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"

	. "github.com/infobip/infobip-api-go-client/v3/pkg/infobip"
	. "github.com/infobip/infobip-api-go-client/v3/pkg/infobip/models/rcs"
)

// RcsAPIService RcsAPI service
type RcsAPIService service

// ApiRcsAPIRequest[T any] interface
type RcsAPIRequest[T any] interface {
	Execute() (*T, *http.Response, error)
}

type ApiCapabilityCheckRcsDestinationsNotifyRequest struct {
	ctx                         context.Context
	ApiService                  *RcsAPIService
	capabilityCheckAsyncRequest *CapabilityCheckAsyncRequest
}

// The request body contains the sender and a list of phone numbers to check for RCS capability.
func (r ApiCapabilityCheckRcsDestinationsNotifyRequest) CapabilityCheckAsyncRequest(capabilityCheckAsyncRequest CapabilityCheckAsyncRequest) ApiCapabilityCheckRcsDestinationsNotifyRequest {
	r.capabilityCheckAsyncRequest = &capabilityCheckAsyncRequest
	return r
}

func (r ApiCapabilityCheckRcsDestinationsNotifyRequest) Execute() (*CapabilityCheckAsyncResponse, *http.Response, error) {
	return r.ApiService.CapabilityCheckRcsDestinationsNotifyExecute(r)
}

/*
CapabilityCheckRcsDestinationsNotify Check RCS capability (async)

Use this endpoint to verify whether the phone numbers in a given list can receive RCS messages from the specified sender. You can check up to 10,000 phone numbers in a single request. The [Capability Check result](#channels/rcs/receive-capability-check-result) returns asynchronously and provides the capability status for each phone number individually.

Ensure the sender is configured and launched on the mobile network/carrier that manages the phone numbers being tested for RCS capability. If the sender is not launched on the network, the capability check request will always return a negative status for the tested phone numbers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCapabilityCheckRcsDestinationsNotifyRequest
*/
func (a *RcsAPIService) CapabilityCheckRcsDestinationsNotify(ctx context.Context) ApiCapabilityCheckRcsDestinationsNotifyRequest {
	return ApiCapabilityCheckRcsDestinationsNotifyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CapabilityCheckAsyncResponse
func (a *RcsAPIService) CapabilityCheckRcsDestinationsNotifyExecute(r ApiCapabilityCheckRcsDestinationsNotifyRequest) (*CapabilityCheckAsyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityCheckAsyncResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.CapabilityCheckRcsDestinationsNotify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/2/capability-check/notify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capabilityCheckAsyncRequest == nil {
		return localVarReturnValue, nil, reportError("capabilityCheckAsyncRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capabilityCheckAsyncRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCapabilityCheckRcsDestinationsQueryRequest struct {
	ctx                        context.Context
	ApiService                 *RcsAPIService
	capabilityCheckSyncRequest *CapabilityCheckSyncRequest
}

func (r ApiCapabilityCheckRcsDestinationsQueryRequest) CapabilityCheckSyncRequest(capabilityCheckSyncRequest CapabilityCheckSyncRequest) ApiCapabilityCheckRcsDestinationsQueryRequest {
	r.capabilityCheckSyncRequest = &capabilityCheckSyncRequest
	return r
}

func (r ApiCapabilityCheckRcsDestinationsQueryRequest) Execute() (*CapabilityCheckSyncResponse, *http.Response, error) {
	return r.ApiService.CapabilityCheckRcsDestinationsQueryExecute(r)
}

/*
CapabilityCheckRcsDestinationsQuery Check RCS capability

Use this endpoint to verify whether the phone numbers in a given list can receive RCS messages from the specified sender. You can check up to 500 phone numbers in a single request; however, for improved efficiency, performance, and response time, we recommend using smaller batches of 1 to 10 numbers in a single request. This synchronous API is typically used for routing purposes when verifying a numberâ€™s RCS capability immediately before sending a message. This API supports up to a 100 requests per second. For bulk database cleanup, we recommend to use the asynchronous Capability Check (CapCheck) API.

The response will provide the list of capability statuses for each phone number individually. Ensure the sender is configured and launched on the mobile network/carrier that manages the phone numbers being tested for RCS capability. If the sender is not launched on the network, the capability check request will always return a negative status for the tested phone numbers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCapabilityCheckRcsDestinationsQueryRequest
*/
func (a *RcsAPIService) CapabilityCheckRcsDestinationsQuery(ctx context.Context) ApiCapabilityCheckRcsDestinationsQueryRequest {
	return ApiCapabilityCheckRcsDestinationsQueryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CapabilityCheckSyncResponse
func (a *RcsAPIService) CapabilityCheckRcsDestinationsQueryExecute(r ApiCapabilityCheckRcsDestinationsQueryRequest) (*CapabilityCheckSyncResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CapabilityCheckSyncResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.CapabilityCheckRcsDestinationsQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/2/capability-check/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capabilityCheckSyncRequest == nil {
		return localVarReturnValue, nil, reportError("capabilityCheckSyncRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.capabilityCheckSyncRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOutboundRcsMessageDeliveryReportsRequest struct {
	ctx                 context.Context
	ApiService          *RcsAPIService
	bulkId              *string
	messageId           *string
	limit               *int32
	entityId            *string
	applicationId       *string
	campaignReferenceId *string
}

// The ID that uniquely identifies the request. Bulk ID will be received only when you send a message to more than one destination address.
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) BulkId(bulkId string) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.bulkId = &bulkId
	return r
}

// The ID that uniquely identifies the message sent.
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) MessageId(messageId string) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.messageId = &messageId
	return r
}

// Maximum number of delivery reports to be returned. If not set, the latest 50 records are returned. Maximum limit value is 1000 and you can only access reports for the last 48h
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) Limit(limit int32) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.limit = &limit
	return r
}

// Entity id used to send the message. For more details, see our [documentation](https://www.infobip.com/docs/cpaas-x/application-and-entity-management).
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) EntityId(entityId string) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.entityId = &entityId
	return r
}

// Application id used to send the message. For more details, see our [documentation](https://www.infobip.com/docs/cpaas-x/application-and-entity-management).
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) ApplicationId(applicationId string) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.applicationId = &applicationId
	return r
}

// ID of a campaign that was sent in the message.
func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) CampaignReferenceId(campaignReferenceId string) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	r.campaignReferenceId = &campaignReferenceId
	return r
}

func (r ApiGetOutboundRcsMessageDeliveryReportsRequest) Execute() (*DeliveryReports, *http.Response, error) {
	return r.ApiService.GetOutboundRcsMessageDeliveryReportsExecute(r)
}

/*
GetOutboundRcsMessageDeliveryReports Get RCS delivery reports

If you are unable to receive real-time delivery reports towards your endpoint for various reasons, we offer you an API method to fetch batches of delivery reports to confirm whether specific messages have been delivered. Each request towards this endpoint will return batches of the latest delivery reports. Please note they will be returned only once.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOutboundRcsMessageDeliveryReportsRequest
*/
func (a *RcsAPIService) GetOutboundRcsMessageDeliveryReports(ctx context.Context) ApiGetOutboundRcsMessageDeliveryReportsRequest {
	return ApiGetOutboundRcsMessageDeliveryReportsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DeliveryReports
func (a *RcsAPIService) GetOutboundRcsMessageDeliveryReportsExecute(r ApiGetOutboundRcsMessageDeliveryReportsRequest) (*DeliveryReports, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeliveryReports
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.GetOutboundRcsMessageDeliveryReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/2/reports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bulkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bulkId", r.bulkId, "form", "")
	}
	if r.messageId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "messageId", r.messageId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.entityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityId", r.entityId, "form", "")
	}
	if r.applicationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationId", r.applicationId, "form", "")
	}
	if r.campaignReferenceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaignReferenceId", r.campaignReferenceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOutboundRcsMessageLogsRequest struct {
	ctx                 context.Context
	ApiService          *RcsAPIService
	sender              *string
	destination         *string
	bulkId              *[]string
	messageId           *[]string
	generalStatus       *MessageGeneralStatus
	sentSince           *Time
	sentUntil           *Time
	limit               *int32
	entityId            *string
	applicationId       *string
	campaignReferenceId *[]string
	useCursor           *bool
	cursor              *string
}

// The sender ID which can be alphanumeric or numeric.
func (r ApiGetOutboundRcsMessageLogsRequest) Sender(sender string) ApiGetOutboundRcsMessageLogsRequest {
	r.sender = &sender
	return r
}

// Message destination address.
func (r ApiGetOutboundRcsMessageLogsRequest) Destination(destination string) ApiGetOutboundRcsMessageLogsRequest {
	r.destination = &destination
	return r
}

// Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request. May contain multiple comma-separated values. Maximum length 2048 characters.
func (r ApiGetOutboundRcsMessageLogsRequest) BulkId(bulkId []string) ApiGetOutboundRcsMessageLogsRequest {
	r.bulkId = &bulkId
	return r
}

// Unique message ID for which a log is requested. May contain multiple comma-separated values. Maximum length 2048 characters.
func (r ApiGetOutboundRcsMessageLogsRequest) MessageId(messageId []string) ApiGetOutboundRcsMessageLogsRequest {
	r.messageId = &messageId
	return r
}

func (r ApiGetOutboundRcsMessageLogsRequest) GeneralStatus(generalStatus MessageGeneralStatus) ApiGetOutboundRcsMessageLogsRequest {
	r.generalStatus = &generalStatus
	return r
}

// The logs will only include messages sent after this date. Use it alongside sentUntil to specify a time range for the logs, but only up to the maximum limit of 1000 logs per call. Has the following format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ.
func (r ApiGetOutboundRcsMessageLogsRequest) SentSince(sentSince Time) ApiGetOutboundRcsMessageLogsRequest {
	r.sentSince = &sentSince
	return r
}

// The logs will only include messages sent before this date. Use it alongside sentSince to specify a time range for the logs, but only up to the maximum limit of 1000 logs per call. Has the following format: yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ.
func (r ApiGetOutboundRcsMessageLogsRequest) SentUntil(sentUntil Time) ApiGetOutboundRcsMessageLogsRequest {
	r.sentUntil = &sentUntil
	return r
}

// Maximum number of messages to include in logs. If not set, the latest 50 records are returned. Maximum limit value is 1000 and you can only access logs for the last 48h.
func (r ApiGetOutboundRcsMessageLogsRequest) Limit(limit int32) ApiGetOutboundRcsMessageLogsRequest {
	r.limit = &limit
	return r
}

// Entity id used to send the message. For more details, see our [documentation](https://www.infobip.com/docs/cpaas-x/application-and-entity-management).
func (r ApiGetOutboundRcsMessageLogsRequest) EntityId(entityId string) ApiGetOutboundRcsMessageLogsRequest {
	r.entityId = &entityId
	return r
}

// Application id used to send the message. For more details, see our [documentation](https://www.infobip.com/docs/cpaas-x/application-and-entity-management).
func (r ApiGetOutboundRcsMessageLogsRequest) ApplicationId(applicationId string) ApiGetOutboundRcsMessageLogsRequest {
	r.applicationId = &applicationId
	return r
}

// ID of a campaign that was sent in the message. May contain multiple comma-separated values.
func (r ApiGetOutboundRcsMessageLogsRequest) CampaignReferenceId(campaignReferenceId []string) ApiGetOutboundRcsMessageLogsRequest {
	r.campaignReferenceId = &campaignReferenceId
	return r
}

// Flag used to enable cursor-based pagination. When set to true, the system will use the cursor to fetch the next set of logs.
func (r ApiGetOutboundRcsMessageLogsRequest) UseCursor(useCursor bool) ApiGetOutboundRcsMessageLogsRequest {
	r.useCursor = &useCursor
	return r
}

// Value which represents the current position in the data set. For the first request, this field shouldn&#39;t be defined. In subsequent requests, use the &#x60;nextCursor&#x60; value returned from the previous response to continue fetching data.
func (r ApiGetOutboundRcsMessageLogsRequest) Cursor(cursor string) ApiGetOutboundRcsMessageLogsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetOutboundRcsMessageLogsRequest) Execute() (*LogResponse, *http.Response, error) {
	return r.ApiService.GetOutboundRcsMessageLogsExecute(r)
}

/*
GetOutboundRcsMessageLogs Get RCS message logs

Use this method for displaying logs for example in the user interface. Available are the logs for the last 48 hours.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOutboundRcsMessageLogsRequest
*/
func (a *RcsAPIService) GetOutboundRcsMessageLogs(ctx context.Context) ApiGetOutboundRcsMessageLogsRequest {
	return ApiGetOutboundRcsMessageLogsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LogResponse
func (a *RcsAPIService) GetOutboundRcsMessageLogsExecute(r ApiGetOutboundRcsMessageLogsRequest) (*LogResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.GetOutboundRcsMessageLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/2/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender", r.sender, "form", "")
	}
	if r.destination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "form", "")
	}
	if r.bulkId != nil {
		t := *r.bulkId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "bulkId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "bulkId", t, "form", "multi")
		}
	}
	if r.messageId != nil {
		t := *r.messageId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "messageId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "messageId", t, "form", "multi")
		}
	}
	if r.generalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "generalStatus", r.generalStatus, "form", "")
	}
	if r.sentSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sentSince", r.sentSince, "form", "")
	}
	if r.sentUntil != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sentUntil", r.sentUntil, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.entityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityId", r.entityId, "form", "")
	}
	if r.applicationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "applicationId", r.applicationId, "form", "")
	}
	if r.campaignReferenceId != nil {
		t := *r.campaignReferenceId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "campaignReferenceId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "campaignReferenceId", t, "form", "multi")
		}
	}
	if r.useCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCursor", r.useCursor, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendRcsEventsRequest struct {
	ctx          context.Context
	ApiService   *RcsAPIService
	eventRequest *EventRequest
}

func (r ApiSendRcsEventsRequest) EventRequest(eventRequest EventRequest) ApiSendRcsEventsRequest {
	r.eventRequest = &eventRequest
	return r
}

func (r ApiSendRcsEventsRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.SendRcsEventsExecute(r)
}

/*
SendRcsEvents Send RCS events

Send RCS events to multiple recipients. Maximum request size is 10MB.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendRcsEventsRequest
*/
func (a *RcsAPIService) SendRcsEvents(ctx context.Context) ApiSendRcsEventsRequest {
	return ApiSendRcsEventsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Response
func (a *RcsAPIService) SendRcsEventsExecute(r ApiSendRcsEventsRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.SendRcsEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/1/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventRequest == nil {
		return localVarReturnValue, nil, reportError("eventRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendRcsMessagesRequest struct {
	ctx            context.Context
	ApiService     *RcsAPIService
	messageRequest *MessageRequest
}

func (r ApiSendRcsMessagesRequest) MessageRequest(messageRequest MessageRequest) ApiSendRcsMessagesRequest {
	r.messageRequest = &messageRequest
	return r
}

func (r ApiSendRcsMessagesRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.SendRcsMessagesExecute(r)
}

/*
SendRcsMessages Send RCS messages

Send RCS messages or RCS template messages to multiple recipients. Maximum request size is 10MB. Including some fields will affect [billing type](https://www.infobip.com/docs/rcs/billing-types).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSendRcsMessagesRequest
*/
func (a *RcsAPIService) SendRcsMessages(ctx context.Context) ApiSendRcsMessagesRequest {
	return ApiSendRcsMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Response
func (a *RcsAPIService) SendRcsMessagesExecute(r ApiSendRcsMessagesRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RcsAPIService.SendRcsMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rcs/2/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageRequest == nil {
		return localVarReturnValue, nil, reportError("messageRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
