/*
Infobip Client API Libraries OpenAPI Specification

OpenAPI specification containing public endpoints supported in client API libraries.

Contact: support@infobip.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package voice

import (
	"encoding/json"
	"fmt"
)

// Language Text language. Must be defined for correct pronunciation. For more details on available languages and voices, see our [documentation](https://www.infobip.com/docs/voice-and-video/outbound-calls#text-to-speech-voice-over-broadcast).
type Language string

// List of Language
const (
	LANGUAGE_AR        Language = "ar"
	LANGUAGE_BN        Language = "bn"
	LANGUAGE_BG        Language = "bg"
	LANGUAGE_CA        Language = "ca"
	LANGUAGE_ZH_CN     Language = "zh-cn"
	LANGUAGE_ZH_TW     Language = "zh-tw"
	LANGUAGE_HR        Language = "hr"
	LANGUAGE_CS        Language = "cs"
	LANGUAGE_DA        Language = "da"
	LANGUAGE_NL        Language = "nl"
	LANGUAGE_EN        Language = "en"
	LANGUAGE_EN_AU     Language = "en-au"
	LANGUAGE_EN_GB     Language = "en-gb"
	LANGUAGE_EN_CA     Language = "en-ca"
	LANGUAGE_EN_IN     Language = "en-in"
	LANGUAGE_EN_IE     Language = "en-ie"
	LANGUAGE_EN_GB_WLS Language = "en-gb-wls"
	LANGUAGE_EPO       Language = "epo"
	LANGUAGE_FIL_PH    Language = "fil-ph"
	LANGUAGE_FI        Language = "fi"
	LANGUAGE_FR        Language = "fr"
	LANGUAGE_FR_CA     Language = "fr-ca"
	LANGUAGE_FR_CH     Language = "fr-ch"
	LANGUAGE_DE        Language = "de"
	LANGUAGE_DE_AT     Language = "de-at"
	LANGUAGE_DE_CH     Language = "de-ch"
	LANGUAGE_EL        Language = "el"
	LANGUAGE_GU        Language = "gu"
	LANGUAGE_HE        Language = "he"
	LANGUAGE_HI        Language = "hi"
	LANGUAGE_HU        Language = "hu"
	LANGUAGE_IS        Language = "is"
	LANGUAGE_ID        Language = "id"
	LANGUAGE_IT        Language = "it"
	LANGUAGE_JA        Language = "ja"
	LANGUAGE_KN        Language = "kn"
	LANGUAGE_KO        Language = "ko"
	LANGUAGE_MS        Language = "ms"
	LANGUAGE_ML        Language = "ml"
	LANGUAGE_NO        Language = "no"
	LANGUAGE_PL        Language = "pl"
	LANGUAGE_PT_PT     Language = "pt-pt"
	LANGUAGE_PT_BR     Language = "pt-br"
	LANGUAGE_RO        Language = "ro"
	LANGUAGE_RU        Language = "ru"
	LANGUAGE_SK        Language = "sk"
	LANGUAGE_SL        Language = "sl"
	LANGUAGE_ES        Language = "es"
	LANGUAGE_ES_GL     Language = "es-gl"
	LANGUAGE_ES_MX     Language = "es-mx"
	LANGUAGE_SV        Language = "sv"
	LANGUAGE_TA        Language = "ta"
	LANGUAGE_TE        Language = "te"
	LANGUAGE_TH        Language = "th"
	LANGUAGE_TR        Language = "tr"
	LANGUAGE_UK        Language = "uk"
	LANGUAGE_VI        Language = "vi"
	LANGUAGE_WLS       Language = "wls"
	LANGUAGE_AR_MA     Language = "ar-ma"
	LANGUAGE_UR_PK     Language = "ur-pk"
)

// All allowed values of Language enum
var AllowedLanguageEnumValues = []Language{
	"ar",
	"bn",
	"bg",
	"ca",
	"zh-cn",
	"zh-tw",
	"hr",
	"cs",
	"da",
	"nl",
	"en",
	"en-au",
	"en-gb",
	"en-ca",
	"en-in",
	"en-ie",
	"en-gb-wls",
	"epo",
	"fil-ph",
	"fi",
	"fr",
	"fr-ca",
	"fr-ch",
	"de",
	"de-at",
	"de-ch",
	"el",
	"gu",
	"he",
	"hi",
	"hu",
	"is",
	"id",
	"it",
	"ja",
	"kn",
	"ko",
	"ms",
	"ml",
	"no",
	"pl",
	"pt-pt",
	"pt-br",
	"ro",
	"ru",
	"sk",
	"sl",
	"es",
	"es-gl",
	"es-mx",
	"sv",
	"ta",
	"te",
	"th",
	"tr",
	"uk",
	"vi",
	"wls",
	"ar-ma",
	"ur-pk",
}

func (v *Language) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := Language(value)
	for _, existing := range AllowedLanguageEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid Language", value)
}

// NewLanguageFromValue returns a pointer to a valid Language
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewLanguageFromValue(v string) (*Language, error) {
	ev := Language(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for Language: valid values are %v", v, AllowedLanguageEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v Language) IsValid() bool {
	for _, existing := range AllowedLanguageEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to Language value
func (v Language) Ptr() *Language {
	return &v
}

type NullableLanguage struct {
	value *Language
	isSet bool
}

func (v NullableLanguage) Get() *Language {
	return v.value
}

func (v *NullableLanguage) Set(val *Language) {
	v.value = val
	v.isSet = true
}

func (v NullableLanguage) IsSet() bool {
	return v.isSet
}

func (v *NullableLanguage) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLanguage(val *Language) *NullableLanguage {
	return &NullableLanguage{value: val, isSet: true}
}

func (v NullableLanguage) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLanguage) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
